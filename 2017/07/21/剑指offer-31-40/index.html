<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="换了一个主题之后Letax全都渲染不出来了，口亨！"><title>剑指offer 31~40 | XxxSssSss</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">剑指offer 31~40</h1><a id="logo" href="/.">XxxSssSss</a><p class="description">啦啦啦~~~</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">剑指offer 31~40</h1><div class="post-meta"><a href="/2017/07/21/剑指offer-31-40/#comments" class="comment-count"></a><p><span class="date">Jul 21, 2017</span><span><a href="/categories/C-笔记/" class="category">C++笔记</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>整数中1出现的次数（从1到n整数中1出现的次数） 把数组排成最小的数 丑数 第一个只出现一次的字符位置 数组中的逆序对<br>两个链表的第一个公共结点 数字在排序数组中出现的次数 二叉树的深度   平衡二叉树 数组中只出现一次的数字</p>
<a id="more"></a>
<h1 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h1><p><strong>分类</strong><br>时间效率<br><strong>题目</strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br><strong>思路</strong><br>从低位到高位依次求出每一位1出现的次数。<br>假设一个数字abcde。想知道c位置1出现了多少次，求解分为两部分：</p>
<ol>
<li>ab为0~ab-1时。c=1，de可取0~99，共计ab*100</li>
<li>ab为ab时。<br>当c&gt;1，de可取0~99，共计100<br>当c=1，de可取0~de，共计de+1<br>当c=0，共计0<br><strong>代码</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
</pre></td><td class="code"><pre><span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int NumberOf1Between1AndN_Solution(int n)</span>
<span class="line">    &#123;</span>
<span class="line">        int ans = 0, ab = n, c, de, exp = 1;</span>
<span class="line">        while (ab) &#123;</span>
<span class="line">            c = ab % 10;</span>
<span class="line">            ab /= 10;</span>
<span class="line">            de = n % exp;</span>
<span class="line">            ans += ab * exp;</span>
<span class="line">            if (c &gt; 1) ans += exp;</span>
<span class="line">            else if (c == 1) ans += de + 1;</span>
<span class="line">            exp *= 10;</span>
<span class="line">        &#125;</span>
<span class="line">        return ans;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p><strong>分类</strong><br>时间效率<br><strong>题目</strong><br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><strong>思路</strong><br>先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。<br>排序规则如下：<br>若ab &gt; ba 则 a &gt; b,<br>若ab &lt; ba 则 a &lt; b,<br>若ab = ba 则 a = b.<br><strong>TIPS</strong><br>使用到了stringstream，详细可看另一篇介绍stringstream用法的文章。<br>把整型数组转化为string数组有两种方法：<br>每次读入一个整型数字，随后就将其转化为字符型数字，注意之后一定要加上<code>stream.clear();</code>这条语句，每次都要重置流的状态标识。<br>或者将所有整形数字全部读入，然后再依次将其读出，注意读入时要用空格或其他符号将其分开。<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
</pre></td><td class="code"><pre><span class="line">// AC1</span>
<span class="line">bool cmp(string s1, string s2) &#123;</span>
<span class="line">    return (s1 + s2) &lt; (s2 + s1);</span>
<span class="line">&#125;</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span>
<span class="line">        stringstream stream;</span>
<span class="line">        vector&lt;string&gt; str;</span>
<span class="line">        for (int i = 0; i &lt; numbers.size(); i ++) &#123;</span>
<span class="line">            string s;</span>
<span class="line">            stream &lt;&lt; numbers[i];</span>
<span class="line">            stream &gt;&gt; s;</span>
<span class="line">            stream.clear();</span>
<span class="line">            str.push_back(s);</span>
<span class="line">        &#125;</span>
<span class="line">        sort(str.begin(), str.end(), cmp);</span>
<span class="line">        string s;</span>
<span class="line">        for (int i = 0; i &lt; str.size(); i ++) &#123;</span>
<span class="line">            s += str[i];</span>
<span class="line">        &#125;</span>
<span class="line">        return s;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line">// AC2</span>
<span class="line">bool cmp(string s1, string s2) &#123;</span>
<span class="line">    return (s1 + s2) &lt; (s2 + s1);</span>
<span class="line">&#125;</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span>
<span class="line">        stringstream stream;</span>
<span class="line">        vector&lt;string&gt; str;</span>
<span class="line">        for (int i = 0; i &lt; numbers.size(); i ++) &#123;</span>
<span class="line">            stream &lt;&lt; numbers[i] &lt;&lt; &apos; &apos;;</span>
<span class="line">        &#125;</span>
<span class="line">        while (stream) &#123;</span>
<span class="line">            string s;</span>
<span class="line">            stream &gt;&gt; s;</span>
<span class="line">            str.push_back(s);</span>
<span class="line">        &#125;</span>
<span class="line">        sort(str.begin(), str.end(), cmp);</span>
<span class="line">        string s;</span>
<span class="line">        for (int i = 0; i &lt; str.size(); i ++) &#123;</span>
<span class="line">            s += str[i];</span>
<span class="line">        &#125;</span>
<span class="line">        return s;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure>
<hr>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p><strong>分类</strong><br>时间空间效率的平衡<br><strong>题目</strong><br>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><strong>思路</strong><br>由于1是最小的丑数，那么从1开始，把<code>2*1</code>，<code>3*1</code>，<code>5*1</code>，进行比较，得出最小的就是1<br>的下一个丑数，也就是<code>2*1</code>，<br>这个时候，多了一个丑数<code>2</code>，也就又多了3个可以比较的丑数，<code>2*2</code>，<code>3*2</code>，<code>5*2</code>，<br>这个时候就把之前<code>1</code>生成的丑数和<code>2</code>生成的丑数加进来也就是<br><code>(3*1,5*1,2*2，3*2，5*2)</code>进行比较，找出最小的……如此循环下去就会发现，<br>每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。<br>这种方法比较暴力，复杂度较高，我们可以使用动态规划的思想，实现一个O(n)的算法。<br>想象有一个数组A放着排列好的丑数，三个队列Q2、Q3、Q5分别表示丑数数组所对应的丑数的2倍、3倍、5倍。即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line">A[]: A[1], A[2], A[3], ...</span>
<span class="line">Q2[]:A[1] * 2, A[2] * 2, A[3] * 2, ...</span>
<span class="line">Q3[]:A[1] * 3, A[2] * 3, A[3] * 3, ...</span>
<span class="line">Q5[]:A[1] * 5, A[2] * 5, A[3] * 5, ...</span>
</pre></td></tr></table></figure></p>
<p>每次弹出三个队列最小的那个队首元素出队，加入到丑数数组的最后，再将这个元素的2倍、3倍、5倍分别加入到三个队列中去。这样我们每次就只比较了队首的三个元素。而这三个队列可以分别用index2、index3、index5来表示读到丑数数组的第几个了，初始都设为0，每当有出队操作时对应队列+1。<br><strong>TIPS</strong><br>注意对vector的初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v; //定义了一个空vector</span>
<span class="line">v[0] = 1; //错误，因为v还没有第一个元素，我们只能索引vector中已经存在的元素</span>
<span class="line"></span>
<span class="line">vector&lt;int&gt; v(10); //定义了一个size为10的vector</span>
<span class="line">v[0] = 1; //正确</span>
</pre></td></tr></table></figure></p>
<p><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
</pre></td><td class="code"><pre><span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int GetUglyNumber_Solution(int index) &#123;</span>
<span class="line">        vector&lt;int&gt; a;</span>
<span class="line">        int index2 = 0, index3 = 0, index5 = 0;</span>
<span class="line">        a.push_back(1);</span>
<span class="line">        while (a.size() &lt; index) &#123;</span>
<span class="line">            int _min = min(a[index2] * 2, min(a[index3] * 3, a[index5] * 5));</span>
<span class="line">            if (_min == a[index2] * 2) index2 ++;</span>
<span class="line">            if (_min == a[index3] * 3) index3 ++;</span>
<span class="line">            if (_min == a[index5] * 5) index5 ++;</span>
<span class="line">            a.push_back(_min);</span>
<span class="line">        &#125;</span>
<span class="line">        return a[index - 1];</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="第一个只出现一次的字符位置"><a href="#第一个只出现一次的字符位置" class="headerlink" title="第一个只出现一次的字符位置"></a>第一个只出现一次的字符位置</h1><p><strong>分类</strong><br>时间空间效率的平衡<br><strong>题目</strong><br>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置<br><strong>思路</strong><br>我么可以初始化一个大小为256的数组与ASCii表对应，记录每个字符第一次出现的位置，具体过程如下：<br>现将数组每个元素初始化为-1，然后从字符串末尾向前遍历这个字符串，如果该字母第一次出现，即对应位置为-1，则记录下这个位置的编号，如果不是第一次出现，那么就是多次出现了，对应位置记录为-2。最终将数组从大到小排序，第一个比-1大的数字即为最小的编号；如果没有则输出-1.<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
</pre></td><td class="code"><pre><span class="line">bool cmp(int a, int b) &#123;</span>
<span class="line">    return a &gt; b;</span>
<span class="line">&#125;</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int FirstNotRepeatingChar(string str) &#123;</span>
<span class="line">        vector&lt;int&gt; v(256, -1);</span>
<span class="line">        for (int i = str.length() - 1; i &gt;= 0; i --) &#123;</span>
<span class="line">            if (v[str[i]] == -1) v[str[i]] = i;</span>
<span class="line">            else if (v[str[i]] &gt;= 0) v[str[i]] = -2;</span>
<span class="line">        &#125;</span>
<span class="line">        sort(v.begin(), v.end(), cmp);</span>
<span class="line">        vector&lt;int&gt; :: iterator it = find(v.begin(), v.end(), -1);</span>
<span class="line">        return it == v.begin() ?  *it : *(-- it);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p><strong>分类</strong><br>时间空间效率的平衡<br><strong>题目</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:<br>题目保证输入的数组中没有的相同的数字<br>数据范围：<br>    对于%50的数据,size&lt;=10^4<br>    对于%75的数据,size&lt;=10^5<br>    对于%100的数据,size&lt;=2<em>10^5<br>示例<br>输入<br>1,2,3,4,5,6,7,0<br>输出<br>7<br><em>*思路</em></em><br>可以应用归并排序的思想来解这一题，每次归并时记录此此归并的逆序数，归并结束时得到一个排好序的数组，同时也能得到总的逆序数。<br>【每一部分内部无论怎么调整，这部分整体相对于除这部分以外的其他部分的逆序不变】<br>例如，下标为归并的某一步，两个排好序的四元数组合成一个八元数组。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前半部分</th>
<th style="text-align:center">后半部分</th>
<th style="text-align:center">归并</th>
<th style="text-align:center">逆序数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2, 6, 7, 9</td>
<td style="text-align:center">1, 4, 8, 11</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2, 6, 7, 9</td>
<td style="text-align:center">4, 8, 11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6, 7, 9</td>
<td style="text-align:center">4, 8, 11</td>
<td style="text-align:center">1, 2</td>
<td style="text-align:center">4 + 0</td>
</tr>
<tr>
<td style="text-align:center">6, 7, 9</td>
<td style="text-align:center">8, 11</td>
<td style="text-align:center">1, 2, 4</td>
<td style="text-align:center">4 + 0 + 3</td>
</tr>
<tr>
<td style="text-align:center">7, 9</td>
<td style="text-align:center">8, 11</td>
<td style="text-align:center">1, 2, 4, 6</td>
<td style="text-align:center">4 + 0 + 3 + 0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">8, 11</td>
<td style="text-align:center">1, 2, 4, 6, 7</td>
<td style="text-align:center">4 + 0 + 3 + 0 + 0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1, 2, 4, 6, 7, 8</td>
<td style="text-align:center">4 + 0 + 3 + 0 + 0 + 1</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>根据上述过程可以看出，每当后半部分队首比较小的时候，前半部分剩余元素的个数即为后半部分队首元素逆序数。换种说法，归并排序时，后半部分队首元素加入到排好序的数组中时，相当于移动到前半部分剩余元素前，从而消除了逆序。<br><strong>TIPS</strong><br>注意使用<code>vector&lt;int&gt; v1(&amp;v[0], &amp;v[mid]);</code>这种写法时所取的数组范围。<br>注意<code>cnt</code>的数据类型，使用<code>int</code>时会溢出。<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
</pre></td><td class="code"><pre><span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span>
<span class="line">        if (data.empty()) return -1;</span>
<span class="line">        MergeSort(data);</span>
<span class="line">        return cnt % 1000000007;</span>
<span class="line">    &#125;</span>
<span class="line">    vector&lt;int&gt; MergeSort(vector&lt;int&gt; v) &#123;</span>
<span class="line">        if (v.size() == 1) return v;</span>
<span class="line">        int mid = v.size() / 2;</span>
<span class="line">        vector&lt;int&gt; v1(&amp;v[0], &amp;v[mid]);</span>
<span class="line">        vector&lt;int&gt; v2(&amp;v[mid], &amp;v[v.size()]);</span>
<span class="line">        v1 = MergeSort(v1);</span>
<span class="line">        v2 = MergeSort(v2);</span>
<span class="line">        return Merge(v1, v2);</span>
<span class="line">    &#125;</span>
<span class="line">    vector&lt;int&gt; Merge(vector&lt;int&gt; v1, vector&lt;int&gt; v2) &#123;</span>
<span class="line">        vector&lt;int&gt; v;</span>
<span class="line">        int i = 0, j = 0;</span>
<span class="line">        while (i &lt; v1.size() &amp;&amp; j &lt; v2.size()) &#123;</span>
<span class="line">            if(v1[i] &lt; v2[j]) &#123;</span>
<span class="line">                v.push_back(v1[i ++]);</span>
<span class="line">            &#125; else &#123;</span>
<span class="line">                v.push_back(v2[j ++]);</span>
<span class="line">                cnt += v1.size() - i;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">        while (i &lt; v1.size()) &#123;</span>
<span class="line">            v.push_back(v1[i ++]);</span>
<span class="line">        &#125;</span>
<span class="line">        while (j &lt; v2.size()) &#123;</span>
<span class="line">            v.push_back(v2[j ++]);</span>
<span class="line">        &#125;</span>
<span class="line">        return v;</span>
<span class="line">    &#125;</span>
<span class="line">private:</span>
<span class="line">    long long cnt = 0;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><p><strong>分类</strong><br>知识迁移能力<br><strong>题目</strong><br>输入两个链表，找出它们的第一个公共结点。<br><strong>思路</strong><br>有公共节点则说明它们有公共的尾部。<br>最简单的想法：找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走<br>下述代码：<br>如果长度相同，一次就能找到；如果长度不同，p1先走1再走2，p2先走2再走1，即可将其看成长度相同的。<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
</pre></td><td class="code"><pre><span class="line">/*</span>
<span class="line">struct ListNode &#123;</span>
<span class="line">    int val;</span>
<span class="line">    struct ListNode *next;</span>
<span class="line">    ListNode(int x) :</span>
<span class="line">            val(x), next(NULL) &#123;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;*/</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span>
<span class="line">        ListNode* p1 = pHead1;</span>
<span class="line">        ListNode* p2 = pHead2;</span>
<span class="line">        while (p1 != p2) &#123;</span>
<span class="line">            p1 = (p1 == NULL) ? pHead2 : p1 -&gt; next;</span>
<span class="line">            p2 = (p2 == NULL) ? pHead1 : p2 -&gt; next;</span>
<span class="line">        &#125;</span>
<span class="line">        return p1;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<p><strong>TIPS</strong><br>为了防止两个链表没有公共节点可以做如下改动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">int flag = 0;</span>
<span class="line">while (p1 != p2 &amp;&amp; flag &lt;= 2) &#123;</span>
<span class="line">    if (p1 == NULL || p2 == NULL) flag ++;//长度不同</span>
<span class="line">    if (p2 == NULL &amp;&amp; p2 == NULL) break;//长度相同</span>
<span class="line">    p1 = (p1 == NULL) ? pHead2 : p1 -&gt; next;</span>
<span class="line">    p2 = (p2 == NULL) ? pHead1 : p2 -&gt; next;</span>
<span class="line">&#125;</span>
<span class="line">return p1;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><p><strong>这题莫名奇妙写了好久……</strong><br><strong>分类</strong><br>知识迁移能力<br><strong>题目</strong><br>统计一个数字在排序数组中出现的次数。<br><strong>思路</strong><br>使用二分查找，找到第一个k和最后一个k的位置，相减。<br><strong>TIPS</strong><br>可以使用<code>count()</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">count(data.begin(),data.end(),k);</span>
</pre></td></tr></table></figure></p>
<p><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
</pre></td><td class="code"><pre><span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span>
<span class="line">        int l = GetL(data, k);</span>
<span class="line">        int r = GetR(data, k);</span>
<span class="line">        </span>
<span class="line">        return r - l + 1;</span>
<span class="line">    &#125;</span>
<span class="line">    int GetL(vector&lt;int&gt; data ,int k) &#123;</span>
<span class="line">        int l = 0, r = data.size() - 1, m;</span>
<span class="line">        while (l &lt;= r) &#123;</span>
<span class="line">            m = (l + r) / 2;</span>
<span class="line">            if (data[m] &lt; k) l = m + 1;</span>
<span class="line">            if (data[m] &gt;= k) r = m - 1;</span>
<span class="line">        &#125;</span>
<span class="line">        return l;</span>
<span class="line">    &#125;</span>
<span class="line">    int GetR(vector&lt;int&gt; data ,int k) &#123;</span>
<span class="line">        int l = 0, r = data.size() - 1, m;</span>
<span class="line">        while (l &lt;= r) &#123;</span>
<span class="line">            m = (l + r) / 2;</span>
<span class="line">            if (data[m] &gt; k) r = m - 1;</span>
<span class="line">            if (data[m] &lt;= k) l = m + 1;</span>
<span class="line">        &#125;</span>
<span class="line">        return r;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p><strong>分类</strong><br>知识迁移能力<br><strong>题目</strong><br>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><strong>思路</strong><br>这题比较简单，递归一下就可以。<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
</pre></td><td class="code"><pre><span class="line">/*</span>
<span class="line">struct TreeNode &#123;</span>
<span class="line">    int val;</span>
<span class="line">    struct TreeNode *left;</span>
<span class="line">    struct TreeNode *right;</span>
<span class="line">    TreeNode(int x) :</span>
<span class="line">            val(x), left(NULL), right(NULL) &#123;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;*/</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    int TreeDepth(TreeNode* pRoot)</span>
<span class="line">    &#123;</span>
<span class="line">        if (pRoot == NULL) return 0;</span>
<span class="line">        return max(TreeDepth(pRoot -&gt; left), TreeDepth(pRoot -&gt; right)) + 1;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<hr>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><strong>分类</strong><br>知识迁移能力<br><strong>题目</strong><br>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br><strong>思路</strong><br>根据平衡二叉树的性质：<strong>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong><br>我们可以延续上一题，直接求解。但这种解法要计算每一个节点的深度，有大量重复计算。<br>更效率的方法是后序遍历这棵树，这样只需遍历一次就可以得到结果。<br><strong>TIPS</strong><br>平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：<strong>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下$F(n)=F(n-1)+F(n-2)+1$ 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。<br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
</pre></td><td class="code"><pre><span class="line">// AC1</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span>
<span class="line">        if (pRoot == NULL) return true;</span>
<span class="line">        bool flag = (abs(TreeDepth(pRoot -&gt; left) - TreeDepth(pRoot -&gt; right)) &lt;= 1);</span>
<span class="line">        return flag &amp;&amp; IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right);</span>
<span class="line">    &#125;</span>
<span class="line">    int TreeDepth(TreeNode* pRoot)</span>
<span class="line">    &#123;</span>
<span class="line">        if (pRoot == NULL) return 0;</span>
<span class="line">        return max(TreeDepth(pRoot -&gt; left), TreeDepth(pRoot -&gt; right)) + 1;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
</pre></td><td class="code"><pre><span class="line">// AC2</span>
<span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span>
<span class="line">        flag = true;</span>
<span class="line">        LRD(pRoot);</span>
<span class="line">        return flag;</span>
<span class="line">    &#125;</span>
<span class="line">    int LRD(TreeNode* pRoot)</span>
<span class="line">    &#123;</span>
<span class="line">        </span>
<span class="line">        if (pRoot == NULL) return 0;</span>
<span class="line">        int d1 = LRD(pRoot -&gt; left);</span>
<span class="line">        int d2 = LRD(pRoot -&gt; right);</span>
<span class="line">        if (abs(d1 - d2) &gt; 1) &#123;</span>
<span class="line">            flag = false;</span>
<span class="line">            return -1;</span>
<span class="line">        &#125;</span>
<span class="line">        return max(d1 + 1, d2 + 1);</span>
<span class="line">        </span>
<span class="line">    &#125;</span>
<span class="line">private:</span>
<span class="line">    bool flag;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure>
<hr>
<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><p><strong>分类</strong><br>知识迁移能力<br><strong>题目</strong><br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><strong>思路</strong><br>根据异或运算的性质，任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。<br>同样将数组中所有数字异或，相同的两个异或结果为零，所以最后异或的结果相当于那两个只出现了一次的数字的异或结果。这个结果必然不为0，所以将结果写为二进制的形式，至少有一位为1，说明那两个数字的二进制形式这一位一定不同。我们以这一位将所有数字划分为两部分，一部分为这一位为0，另一部分为这一位为1。<br>将这两部分的数字分别异或求和，思路同上，则能得出这两个只出现一次的数。<br><strong>TIPS</strong><br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为<code>⊕</code>，计算机符号为<code>xor</code>。其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。<br>若x是二进制数0101，y是二进制数1011，则x⊕y=1110<br>若x是二进制数0101，y是二进制数0101，则x⊕y=0000</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A⊕B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p><strong>与其它语言不同，C语言和C++语言的异或不用xor，而是用<code>^</code>，键入方式为Shift+6。（而其它语言的<code>^</code>一般表示乘方）</strong><br><strong>代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
</pre></td><td class="code"><pre><span class="line">class Solution &#123;</span>
<span class="line">public:</span>
<span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span>
<span class="line">        int len = data.size(), res = 0, index;</span>
<span class="line">        for (int i = 0; i &lt; len; i ++) &#123;</span>
<span class="line">            res ^= data[i];</span>
<span class="line">        &#125;</span>
<span class="line">        for (index = 0; index &lt; 32; index ++) &#123;</span>
<span class="line">            if ((res &amp; (1 &lt;&lt; index)) != 0) break;</span>
<span class="line">        &#125;</span>
<span class="line">        * num1 = 0, * num2 = 0;</span>
<span class="line">        for (int i = 0; i &lt; len; i ++) &#123;</span>
<span class="line">            if ((data[i] &amp; (1 &lt;&lt; index)) != 0)</span>
<span class="line">                * num1 ^= data[i];</span>
<span class="line">            else * num2 ^= data[i];</span>
<span class="line">        &#125;</span>
<span class="line">        return ;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;;</span>
</pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/时间效率/">时间效率</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/07/22/位运算/" class="pre">位运算</a><a href="/2017/07/21/vector的初始化/" class="next">【C++】vector介绍</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#整数中1出现的次数（从1到n整数中1出现的次数）"><span class="toc-text">整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#把数组排成最小的数"><span class="toc-text">把数组排成最小的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#丑数"><span class="toc-text">丑数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个只出现一次的字符位置"><span class="toc-text">第一个只出现一次的字符位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中的逆序对"><span class="toc-text">数组中的逆序对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两个链表的第一个公共结点"><span class="toc-text">两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数字在排序数组中出现的次数"><span class="toc-text">数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树的深度"><span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#平衡二叉树"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中只出现一次的数字"><span class="toc-text">数组中只出现一次的数字</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/Deep-Learning/">【深度学习】深度神经网络入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/test/">机器学习1：有趣的机器学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/系统中多版本Python的切换与Python第三方库的安装/">系统中多版本Python的切换与Python第三方库的安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/22/位运算/">位运算</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/剑指offer-31-40/">剑指offer 31~40</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/vector的初始化/">【C++】vector介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/19/stringstream/">【C++】stringstream的使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/Tensorflow5/">【神经网络】通过代码学习Tensorflow5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/Tensorflow4/">【神经网络】通过代码学习Tensorflow4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/04/Tensorflow3/">【神经网络】通过代码学习Tensorflow3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-笔记/">C++笔记</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术文档/">技术文档</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习笔记/">机器学习笔记</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习笔记/">深度学习笔记</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习笔记/">算法学习笔记</a><span class="category-list-count">12</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/神经网络/" style="font-size: 15px;">神经网络</a> <a href="/tags/近似算法/" style="font-size: 15px;">近似算法</a> <a href="/tags/Graham-s-Scan/" style="font-size: 15px;">Graham's Scan</a> <a href="/tags/基本概念/" style="font-size: 15px;">基本概念</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/概率论/" style="font-size: 15px;">概率论</a> <a href="/tags/RBM/" style="font-size: 15px;">RBM</a> <a href="/tags/DBN/" style="font-size: 15px;">DBN</a> <a href="/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/tags/RNN/" style="font-size: 15px;">RNN</a> <a href="/tags/Autoencoder/" style="font-size: 15px;">Autoencoder</a> <a href="/tags/RNTN/" style="font-size: 15px;">RNTN</a> <a href="/tags/线性代数/" style="font-size: 15px;">线性代数</a> <a href="/tags/数值计算/" style="font-size: 15px;">数值计算</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/权值衰减/" style="font-size: 15px;">权值衰减</a> <a href="/tags/范数/" style="font-size: 15px;">范数</a> <a href="/tags/分治算法/" style="font-size: 15px;">分治算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/贪心/" style="font-size: 15px;">贪心</a> <a href="/tags/数学基础/" style="font-size: 15px;">数学基础</a> <a href="/tags/MathJax/" style="font-size: 15px;">MathJax</a> <a href="/tags/LaTex/" style="font-size: 15px;">LaTex</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Matplotlib/" style="font-size: 15px;">Matplotlib</a> <a href="/tags/感知机/" style="font-size: 15px;">感知机</a> <a href="/tags/sigmoid神经元/" style="font-size: 15px;">sigmoid神经元</a> <a href="/tags/凸包/" style="font-size: 15px;">凸包</a> <a href="/tags/梯度下降/" style="font-size: 15px;">梯度下降</a> <a href="/tags/Numpy/" style="font-size: 15px;">Numpy</a> <a href="/tags/数据处理/" style="font-size: 15px;">数据处理</a> <a href="/tags/Panadas/" style="font-size: 15px;">Panadas</a> <a href="/tags/信息学/" style="font-size: 15px;">信息学</a> <a href="/tags/sklearn/" style="font-size: 15px;">sklearn</a> <a href="/tags/随机算法/" style="font-size: 15px;">随机算法</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/tensorboard/" style="font-size: 15px;">tensorboard</a> <a href="/tags/dropout/" style="font-size: 15px;">dropout</a> <a href="/tags/搜索/" style="font-size: 15px;">搜索</a> <a href="/tags/VC维/" style="font-size: 15px;">VC维</a> <a href="/tags/VPN/" style="font-size: 15px;">VPN</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/堆/" style="font-size: 15px;">堆</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/vector/" style="font-size: 15px;">vector</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/位运算/" style="font-size: 15px;">位运算</a> <a href="/tags/链表/" style="font-size: 15px;">链表</a> <a href="/tags/递归和循环/" style="font-size: 15px;">递归和循环</a> <a href="/tags/代码的完整性/" style="font-size: 15px;">代码的完整性</a> <a href="/tags/代码的鲁棒性/" style="font-size: 15px;">代码的鲁棒性</a> <a href="/tags/抽象具体化/" style="font-size: 15px;">抽象具体化</a> <a href="/tags/举例让抽象具体化/" style="font-size: 15px;">举例让抽象具体化</a> <a href="/tags/分解让复杂问题简单/" style="font-size: 15px;">分解让复杂问题简单</a> <a href="/tags/时间效率/" style="font-size: 15px;">时间效率</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Xu Shanshan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>